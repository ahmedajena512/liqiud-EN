
import express from 'express';
import cors from 'cors';
import dotenv from 'dotenv';
import Replicate from 'replicate';
import { GoogleGenAI } from "@google/genai";

dotenv.config();

const app = express();
const port = process.env.PORT || 3001;

// Middleware
app.use(cors());
// Increase limit for base64 images
app.use(express.json({ limit: '50mb' }));

// Replicate Client
const replicate = new Replicate({
  auth: process.env.REPLICATE_API_TOKEN || "r8_J8QaYRuWLsWO7D62qHci4IH9pXl4FRG3VdCfO",
});

// Google GenAI Client
const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });

console.log("Server initialized.");

// --- Endpoints ---

/**
 * POST /api/edit
 * Edits the image using Gemini (Banana Pro) for Outpainting/Zooming
 */
app.post('/api/edit', async (req, res) => {
  try {
    const { image, zoom, aspectRatio } = req.body;

    if (!image) {
      return res.status(400).json({ error: 'Image is required' });
    }

    // Clean base64 string
    const base64Data = image.replace(/^data:image\/\w+;base64,/, "");

    // Logic: If zoom > 1, we are "Zooming Out" (Outpainting).
    // The prompt needs to explicitly tell the model to fill in the new space.
    let promptInstruction = '';
    
    if (zoom > 1) {
       promptInstruction = `
         The user wants to "zoom out" of this image by a factor of ${zoom}x. 
         Keep the original subject in the center exactly as it is (do not alter faces or key details).
         GENERATE new background/surroundings to fill the wider frame naturally.
         The new content should match the lighting, style, and context of the original image seamlessly.
       `;
    } else {
       promptInstruction = `
         Reframing the image to aspect ratio ${aspectRatio}. 
         Ensure the subject remains the focus.
       `;
    }

    const finalPrompt = `
      Task: Image Editing / Outpainting.
      ${promptInstruction}
      Target Aspect Ratio: ${aspectRatio}.
      Output: High-resolution, photorealistic image.
    `;

    console.log(`Starting Edit: ${aspectRatio}, Zoom: ${zoom}x`);

    const response = await ai.models.generateContent({
      model: 'gemini-3-pro-image-preview',
      contents: {
        parts: [
          {
            inlineData: {
              data: base64Data,
              mimeType: 'image/jpeg',
            },
          },
          {
            text: finalPrompt,
          },
        ],
      },
      config: {
        imageConfig: {
          aspectRatio: aspectRatio === '1:1' ? '1:1' : 
                       aspectRatio === '16:9' ? '16:9' : 
                       aspectRatio === '9:16' ? '9:16' : 
                       aspectRatio === '4:3' ? '4:3' : 
                       aspectRatio === '3:4' ? '3:4' : undefined
        }
      }
    });

    let outputImage = null;

    // Extract image from response
    if (response.candidates && response.candidates[0].content.parts) {
       for (const part of response.candidates[0].content.parts) {
         if (part.inlineData) {
           outputImage = `data:image/png;base64,${part.inlineData.data}`;
           break;
         }
       }
    }

    if (!outputImage) {
      throw new Error("No image generated by Gemini.");
    }

    res.json({ output: outputImage });

  } catch (error) {
    console.error('Edit Error:', error);
    res.status(500).json({ error: error.message || 'Failed to edit image' });
  }
});

/**
 * POST /api/predict
 * Starts the enhancement process
 */
app.post('/api/predict', async (req, res) => {
  try {
    const { image, scale, face_enhance } = req.body;

    if (!image) {
      console.error("Error: No image provided in request");
      return res.status(400).json({ error: 'Image is required' });
    }

    console.log(`Starting prediction: Scale x${scale}, Face Enhance: ${face_enhance}`);

    const prediction = await replicate.predictions.create({
      model: "nightmareai/real-esrgan",
      input: {
        image,
        scale: Number(scale) || 4,
        face_enhance: Boolean(face_enhance),
      },
    });

    res.status(201).json(prediction);
  } catch (error) {
    console.error('Prediction Creation Error:', error);
    res.status(500).json({ error: error.message || 'Failed to create prediction' });
  }
});

/**
 * GET /api/prediction/:id
 * Polls status
 */
app.get('/api/prediction/:id', async (req, res) => {
  try {
    const prediction = await replicate.predictions.get(req.params.id);
    res.json({
      id: prediction.id,
      status: prediction.status,
      output: prediction.output,
      error: prediction.error,
      metrics: prediction.metrics,
      logs: prediction.logs
    });
  } catch (error) {
    console.error(`Polling Error for ${req.params.id}:`, error.message);
    res.status(500).json({ error: 'Failed to get status' });
  }
});

app.listen(port, () => {
  console.log(`Server running at http://localhost:${port}`);
});
